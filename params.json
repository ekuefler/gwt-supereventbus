{"name":"SuperEventBus","tagline":"High-octane event bus for GWT","body":"What is SuperEventBus?\r\n======================\r\n\r\nSuperEventBus is a high-powered event bus for GWT. It is a replacement for the\r\nbuilt-in com.google.web.bindery.event.shared.EventBus.\r\n\r\nSuperEventBus is currently an *experimental* API that is subject to change.\r\nPlease leave feedback and feature requests in the [issue tracker][0]!\r\n\r\nWhy do I need a new event bus?\r\n==============================\r\n\r\nGWT's event bus is a great way to make your application more maintainable by\r\ndecoupling components from one another, allowing you to work on one without\r\naffecting the others. However, the built-in event bus has several limitations.\r\nSpecifically,\r\n\r\n * It's *inflexible*. All events in GWT's event system must extend an `Event`\r\n   class, requiring you to define a new event for any kind of data that must be\r\n   posted on the event bus. Like Guava's event bus, SuperEventBus allows you to\r\n   post any type of event, allowing you to do things like update model objects\r\n   by posting them directly on the bus. Handlers in GWT's event bus are also\r\n   always active when registered - SuperEventBus allows you to define filters\r\n   that can prevent events from being handled in certain situations (say, when\r\n   the component is not visible.)\r\n * It's *verbose*. Extending `Event` requires implementing several boilerplate\r\n   methods, and registering handlers usually requires creating clunky anonymous\r\n   classes. SuperEventBus again takes inspiration from Guava, allowing you to\r\n   annotate existing methods with the `@Subscribe` annotation to cause them to\r\n   be automatically registered as event handlers.\r\n * It's *monomorphic*. A handler registered for a given event type will only hear\r\n   instances of that exact type and none of its subtypes. This requires you to\r\n   register redundant handlers for events that should be handled in similar ways.\r\n   In contrast, SuperEventBus's handlers a fully polymorphic, so a handler for a\r\n   given type will be invoked whenever any subtype of that event is posted. This\r\n   lets you do powerful things, like defining tagging interfaces for events that\r\n   share properties that should be handled in the same way, or even registering a\r\n   handler for `Object` that will receive every event in the system. When just a\r\n   single polymorphic type still isn't enough, SuperEventBus also allows the use\r\n   of MultiEvents to handle many events with unrelated types using a single\r\n   handler method.\r\n * It's *unpredictable*. GWT's event bus dispatches events using a stack, so that\r\n   when one event fires another event it can be impossible to tell which order\r\n   other handlers will see those events in. There is also no way to tell GWT that\r\n   certain handlers should always be invoked before or after other handlers.\r\n   SuperEventBus uses a queue that guarantees events will always be handled in\r\n   the same order in which they're fired, and allows you to specify priorities\r\n   for handlers to affect the order in which they are invoked.\r\n\r\nSuperEventBus addresses all of these problems and more, providing a more powerful\r\nevent bus that is easier to use.\r\n\r\nHow do I use SuperEventBus?\r\n===========================\r\n\r\nSuperEventBus uses a simple annotation-based interface inspired by [Guava's event\r\nbus][1]. To define a handler method, just annotate a non-private method that \r\ntakes a single argument with the `@Subscribe` annotation like this:\r\n\r\n```java\r\n@Subscribe\r\nvoid handleString(String event) {\r\n  Window.alert(\"The string \" + event + \" was posted on the event bus.\");\r\n}\r\n```\r\n\r\nA class may contain any number of methods annotated with `@Subscribe`. In order\r\nto active them, the class must first declare an event registration interface for\r\nthe class:\r\n\r\n```java\r\ninterface MyRegistration extends EventRegistration<MyClass> {}\r\n```\r\n\r\nThen, the class just needs to register itself with an instance of the event bus\r\n(this is usually done in the constructor of the class):\r\n\r\n```java\r\neventBus.register(this, MyRegistration.class);\r\n```\r\n\r\nOnce registered, `handleString` will be invoked whenever a `String` is posted on\r\nthe event bus, which is done like this:\r\n\r\n```java\r\neventBus.post(\"some string\");\r\n```\r\n\r\nOf course, you aren't restricted to posting strings: handler methods can be\r\ndefined for any type and any type can be passed to `post`. In practice, most\r\nusers will define their own event types rather than posting existing types\r\ndirectly.\r\n\r\nWhat else can it do?\r\n====================\r\n\r\nSuperEventBus contains several advanced features that have no analogue in GWT's\r\nbuilt-in event bus. It's easy to get started with SuperEventBus without these\r\nfeatures, and explore them later as needed.\r\n\r\n### Priorities\r\n\r\nIn addition to `@Subscribe`, handler methods can also be annotated with the\r\n`@WithPriority` annotation, which takes a single integer. Handlers with higher\r\npriorities are always invoked before handlers with lower priorities. Handlers\r\nwithout the `@WithPriority` annotation are given priority 0, and negative\r\npriorities are allowed. See the [javadoc][2] for more details.\r\n\r\n### Filters\r\n\r\nHandler methods can also be annotated with the `@When` annotation, which takes\r\na filter class and causes that handler to be ignored when the filter returns\r\nfalse. Filter classes extend `EventFilter` and look like this:\r\n\r\n```java\r\nclass IsVisible implements EventFilter<HasVisibility, Object> {\r\n  @Override\r\n  public boolean accepts(HasVisibility handler, Object event) {\r\n    return handler.isVisible();\r\n  }\r\n}\r\n```\r\n\r\nA handler annotated with `@When(IsVisible.class)` would be invoked only if its\r\ncontaining class was visible at the time the event was posted. Note that the\r\nfilter accepts both the handler class as well as the event, so it is possible\r\nto filter based on the properties of either. See the [javadoc][3] for more\r\ndetails.\r\n\r\n### MultiEvents\r\n\r\nSince EventBus is polymorphic, it is usually possible to handle many types of\r\nevents by defining a handler for a common base class of those events. However,\r\nsometimes it is necessary to handle multiple events of unrelated types. This\r\ncan be accomplished by declaring a handler with a paramter of type `MultiEvent`\r\nand annotating it with `EventTypes` as follows:\r\n\r\n```java\r\n@Subscribe\r\nvoid handleMultipleTypes(@EventTypes({String.class, Double.class}) MultiEvent event) {\r\n  if (event instanceof String) {\r\n    Window.alert(\"Got a string: \" + event.getEvent());\r\n  } else if (event instanceof Double) {\r\n    Window.alert(\"Got a double: \" + event.getEvent());\r\n  }\r\n}\r\n```\r\n\r\nThe given handler would be invoked whenever a `String` or `Double` was posted on\r\nthe event bus, and the actual event would be accessible via the `getEvent` method\r\non `MultiEvent`. See the [javadoc][4] for more details.\r\n\r\n### Dead events\r\n\r\nIf an event is fired that has no registered handlers, SuperEventBus will wrap\r\nthat event in a `DeadEvent` and re-fire it. This makes it possible to register a\r\nhandler for `DeadEvent` that can do something like log a warning when an event\r\nwithout a handler is fired, which can help detect misconfiguration issues. Note\r\nthat `DeadEvent` will never be fired if a handler for `Object` is registered,\r\nsince that handler will receive every event posted on the event bus. See the\r\n[javadoc][5] for more details.\r\n\r\nHow do I install it?\r\n====================\r\n\r\nIf you're using Maven, you can add the following to your `<dependencies>`\r\nsection:\r\n\r\n```xml\r\n<dependency>\r\n  <groupId>com.ekuefler.supereventbus</groupId>\r\n  <artifactId>supereventbus</artifactId>\r\n  <version>alpha1</version>\r\n</dependency>\r\n```\r\n\r\nYou can also download the [jar][6] directly or check out the source using git\r\nfrom <https://github.com/ekuefler/gwt-supereventbus.git>.\r\n\r\n[0]: TODO\r\n[1]: https://code.google.com/p/guava-libraries/wiki/EventBusExplained\r\n[2]: TODO\r\n[3]: TODO\r\n[4]: TODO\r\n[5]: TODO\r\n[6]: TODO\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}